# #######################################
#
# HAL file for BeagleBone + TCT paralell port cape with 5 steppers and 3D printer board
#
# Derived from example hm2-stepper config
#
# ########################################

# Launch the setup script to make sure hardware setup looks good
loadusr -w ./setup.sh


# ###################################
# Core EMC/HAL Loads
# ###################################

# kinematics
loadrt trivkins

# motion controller, get name and thread periods from ini file
loadrt [EMCMOT]EMCMOT servo_period_nsec=[EMCMOT]SERVO_PERIOD num_joints=5 #[TRAJ]AXES
# Gantry component for Z Axis
loadrt gantry personality=2

# load low-level drivers
loadrt hal_bb_gpio output_pins=107,119,126 input_pins=241
loadrt [PRUCONF](DRIVER) [PRUCONF](CONFIG)
loadrt pid num_chan=2
loadrt limit1 count=2
loadrt scale count=1
loadrt led_dim count=3


# Python user-mode HAL module to read ADC value and generate a thermostat output for PWM
# t = Thermistor table (only epcos_B57560G1104 or 1 supported for now)
# a = analog input channel
#loadusr -Wn Therm /home/linuxcnc/linuxcnc/configs/ARM/BeagleBone/BeBoPr-Bridge/ReadTemp.py -n Therm --num_chan 2 -t 1 1 -a 4 5

# Python user-mode HAL module to interface with an I2C gpio extender
loadusr -Wn i2c_gpio ./python/Gpio.py --name i2c_gpio --bus_id 2 --address 32 --interval 0.05 --input_pins A00,A01,A02,A03,A04,A05

# Python user-mode HAL module to interface with an I2C PWM generator
loadusr -Wn i2c_pwm ./python/Pwm.py --name i2c_pwm --bus_id 2 --address 70 --interval 0.05

# Python user-mode HAL module to interface with an I2C ADC and convert it to temperature
loadusr -Wn i2c_temp ./python/Temperature.py --name i2c_temp --bus_id 2 --address 72 --interval 0.05 --filter_size 20 --channels 00:epcos_B57560G1104,02:artifex_hb

# start haltalk server
loadusr -W haltalk --ini haltalk.ini

# ################################################
# THREADS
# ################################################
loadrt threads name1=run-thread period1=100000000

addf [PRUCONF](DRIVER).capture-position   servo-thread
addf bb_gpio.read                         servo-thread
addf motion-command-handler               servo-thread
addf motion-controller                    servo-thread
addf pid.0.do-pid-calcs                   servo-thread
addf pid.1.do-pid-calcs                   servo-thread
addf limit1.0                             servo-thread
addf limit1.1                             servo-thread
addf [PRUCONF](DRIVER).update             servo-thread
addf bb_gpio.write                        servo-thread
addf scale.0                              servo-thread
addf gantry.0.read                        servo-thread
addf gantry.0.write                       servo-thread
addf led-dim.0.update   run-thread
addf led-dim.1.update   run-thread
addf led-dim.2.update   run-thread

# wait the halcmd script until the UI has created the remote component 'pidctrl':
# waitexists pidctrl

# OR preconfigure the remote component like so
# in this case no waiting required
# pin count, name, type, direction must match exactly what
# is in the GUI
newcomp pidctrl timer=100 acceptdefaults
newpin pidctrl pidctrl.Pgain              float out
newpin pidctrl pidctrl.Igain              float out
newpin pidctrl pidctrl.Dgain              float out
newpin pidctrl pidctrl.maxerrorI          float out
newpin pidctrl pidctrl.bias               float out
newpin pidctrl pidctrl.enable             bit out
newpin pidctrl pidctrl.command            float out
newpin pidctrl pidctrl.feedback           float in eps=0.01
ready  pidctrl

newcomp ledctrl timer=100 acceptdefaults
newpin ledctrl ledctrl.color.r            u32 out
newpin ledctrl ledctrl.color.g            u32 out
newpin ledctrl ledctrl.color.b            u32 out
newpin ledctrl ledctrl.color.a            u32 out
newpin ledctrl ledctrl.color.h            float out
newpin ledctrl ledctrl.color.s            float out
newpin ledctrl ledctrl.color.v            float out
ready  ledctrl

# at this stage, the component and its pins exist
# and can be linked to
       

# ############1##########################################
# Axis-of-motion Specific Configs (not the GUI)
# ######################################################


# ################
# X [0] Axis
# ################

# axis enable chain
newsig emcmot.00.enable bit
sets emcmot.00.enable FALSE

net emcmot.00.enable <= axis.0.amp-enable-out 
net emcmot.00.enable => [PRUCONF](DRIVER).stepgen.00.enable


# position command and feedback
net emcmot.00.pos-cmd <= axis.0.motor-pos-cmd
net emcmot.00.pos-cmd => [PRUCONF](DRIVER).stepgen.00.position-cmd

net motor.00.pos-fb <= [PRUCONF](DRIVER).stepgen.00.position-fb
net motor.00.pos-fb => axis.0.motor-pos-fb


# timing parameters
setp [PRUCONF](DRIVER).stepgen.00.dirsetup        [AXIS_0]DIRSETUP
setp [PRUCONF](DRIVER).stepgen.00.dirhold         [AXIS_0]DIRHOLD

setp [PRUCONF](DRIVER).stepgen.00.steplen         [AXIS_0]STEPLEN
setp [PRUCONF](DRIVER).stepgen.00.stepspace       [AXIS_0]STEPSPACE

setp [PRUCONF](DRIVER).stepgen.00.position-scale  [AXIS_0]SCALE

setp [PRUCONF](DRIVER).stepgen.00.maxvel          [AXIS_0]STEPGEN_MAX_VEL
setp [PRUCONF](DRIVER).stepgen.00.maxaccel        [AXIS_0]STEPGEN_MAX_ACC

#setp [PRUCONF](DRIVER).stepgen.00.step_type       0
# P8.12
setp [PRUCONF](DRIVER).stepgen.00.steppin         0x4C
# P8.11
setp [PRUCONF](DRIVER).stepgen.00.dirpin          0x4D


# ################
# Y [1] Axis
# ################

# axis enable chain
newsig emcmot.01.enable bit
sets emcmot.01.enable FALSE

net emcmot.01.enable <= axis.1.amp-enable-out 
net emcmot.01.enable => [PRUCONF](DRIVER).stepgen.01.enable


# position command and feedback
net emcmot.01.pos-cmd <= axis.1.motor-pos-cmd
net emcmot.01.pos-cmd => [PRUCONF](DRIVER).stepgen.01.position-cmd

net motor.01.pos-fb <= [PRUCONF](DRIVER).stepgen.01.position-fb
net motor.01.pos-fb => axis.1.motor-pos-fb


# timing parameters
setp [PRUCONF](DRIVER).stepgen.01.dirsetup        [AXIS_1]DIRSETUP
setp [PRUCONF](DRIVER).stepgen.01.dirhold         [AXIS_1]DIRHOLD

setp [PRUCONF](DRIVER).stepgen.01.steplen         [AXIS_1]STEPLEN
setp [PRUCONF](DRIVER).stepgen.01.stepspace       [AXIS_1]STEPSPACE

setp [PRUCONF](DRIVER).stepgen.01.position-scale  [AXIS_1]SCALE

setp [PRUCONF](DRIVER).stepgen.01.maxvel          [AXIS_1]STEPGEN_MAX_VEL
setp [PRUCONF](DRIVER).stepgen.01.maxaccel        [AXIS_1]STEPGEN_MAX_ACC

#setp [PRUCONF](DRIVER).stepgen.01.step_type       0
# P8.16
setp [PRUCONF](DRIVER).stepgen.01.steppin         0x4E
# P8.15
setp [PRUCONF](DRIVER).stepgen.01.dirpin          0x4F


# ################
# Z [2] Axis
# ################

# axis enable chain
newsig emcmot.02.enable bit
sets emcmot.02.enable FALSE

net emcmot.02.enable <= axis.2.amp-enable-out 
net emcmot.02.enable => [PRUCONF](DRIVER).stepgen.02.enable


# position command and feedback
net emcmot.02.pos-cmd <= axis.2.motor-pos-cmd
#net emcmot.02.pos-cmd => [PRUCONF](DRIVER).stepgen.02.position-cmd
net emcmot.02.pos-cmd => gantry.0.position-cmd
net motor.02.pos-cmd <= gantry.0.joint.00.pos-cmd 
net motor.02.pos-cmd => [PRUCONF](DRIVER).stepgen.02.position-cmd

net emcmot.02.pos-fb <= gantry.0.position-fb
net emcmot.02.pos-fb => axis.2.motor-pos-fb
net motor.02.pos-fb <= [PRUCONF](DRIVER).stepgen.02.position-fb
net motor.02.pos-fb => gantry.0.joint.00.pos-fb

# timing parameters
setp [PRUCONF](DRIVER).stepgen.02.dirsetup        [AXIS_2]DIRSETUP
setp [PRUCONF](DRIVER).stepgen.02.dirhold         [AXIS_2]DIRHOLD

setp [PRUCONF](DRIVER).stepgen.02.steplen         [AXIS_2]STEPLEN
setp [PRUCONF](DRIVER).stepgen.02.stepspace       [AXIS_2]STEPSPACE

setp [PRUCONF](DRIVER).stepgen.02.position-scale  [AXIS_2]SCALE

setp [PRUCONF](DRIVER).stepgen.02.maxvel          [AXIS_2]STEPGEN_MAX_VEL
setp [PRUCONF](DRIVER).stepgen.02.maxaccel        [AXIS_2]STEPGEN_MAX_ACC

#setp [PRUCONF](DRIVER).stepgen.02.step_type       0
# P9.13
setp [PRUCONF](DRIVER).stepgen.02.steppin         0x3F
# P9.25
setp [PRUCONF](DRIVER).stepgen.02.dirpin          0x95


# ################
# Z [3] Axis
# ################

# axis enable chain
#newsig emcmot.03.enable bit
#sets emcmot.03.enable FALSE

#net emcmot.03.enable <= axis.2.amp-enable-out 
net emcmot.02.enable => [PRUCONF](DRIVER).stepgen.03.enable


# position command and feedback
#net emcmot.03.pos-cmd <= axis.2.motor-pos-cmd
#net emcmot.02.pos-cmd => [PRUCONF](DRIVER).stepgen.03.position-cmd
net motor.03.pos-cmd <= gantry.0.joint.01.pos-cmd
net motor.03.pos-cmd => [PRUCONF](DRIVER).stepgen.03.position-cmd

#net motor.02.pos-fb <= [PRUCONF](DRIVER).stepgen.03.position-fb
#net motor.03.pos-fb => axis.2.motor-pos-fb
net motor.03.pos-fb <= [PRUCONF](DRIVER).stepgen.03.position-fb
net motor.03.pos-fb => gantry.0.joint.01.pos-fb

# timing parameters
setp [PRUCONF](DRIVER).stepgen.03.dirsetup        [AXIS_2]DIRSETUP
setp [PRUCONF](DRIVER).stepgen.03.dirhold         [AXIS_2]DIRHOLD

setp [PRUCONF](DRIVER).stepgen.03.steplen         [AXIS_2]STEPLEN
setp [PRUCONF](DRIVER).stepgen.03.stepspace       [AXIS_2]STEPSPACE

setp [PRUCONF](DRIVER).stepgen.03.position-scale  [AXIS_2]SCALE

setp [PRUCONF](DRIVER).stepgen.03.maxvel          [AXIS_2]STEPGEN_MAX_VEL
setp [PRUCONF](DRIVER).stepgen.03.maxaccel        [AXIS_2]STEPGEN_MAX_ACC

#setp [PRUCONF](DRIVER).stepgen.03.step_type       0
# P9.22
setp [PRUCONF](DRIVER).stepgen.03.steppin         0x22
# P9.21
setp [PRUCONF](DRIVER).stepgen.03.dirpin          0x23


# ################
# A [4] Axis (Extruder)
# ################

# axis enable chain
newsig emcmot.03.enable bit
sets emcmot.03.enable FALSE

net emcmot.03.enable <= axis.3.amp-enable-out 
net emcmot.03.enable => [PRUCONF](DRIVER).stepgen.04.enable


# position command and feedback
net emcmot.03.pos-cmd <= axis.3.motor-pos-cmd
net emcmot.03.pos-cmd => [PRUCONF](DRIVER).stepgen.04.position-cmd

net motor.04.pos-fb <= [PRUCONF](DRIVER).stepgen.04.position-fb
net motor.04.pos-fb => axis.3.motor-pos-fb


# timing parameters
setp [PRUCONF](DRIVER).stepgen.04.dirsetup        [AXIS_3]DIRSETUP
setp [PRUCONF](DRIVER).stepgen.04.dirhold         [AXIS_3]DIRHOLD

setp [PRUCONF](DRIVER).stepgen.04.steplen         [AXIS_3]STEPLEN
setp [PRUCONF](DRIVER).stepgen.04.stepspace       [AXIS_3]STEPSPACE

setp [PRUCONF](DRIVER).stepgen.04.position-scale  [AXIS_3]SCALE

setp [PRUCONF](DRIVER).stepgen.04.maxvel          [AXIS_3]STEPGEN_MAX_VEL
setp [PRUCONF](DRIVER).stepgen.04.maxaccel        [AXIS_3]STEPGEN_MAX_ACC

#setp [PRUCONF](DRIVER).stepgen.04.step_type       0
# P9.11
setp [PRUCONF](DRIVER).stepgen.04.steppin         0x3E
# P9.42
setp [PRUCONF](DRIVER).stepgen.04.dirpin          0x27


# ##################################################
# Standard I/O - EStop, Enables, Limit Switches, Etc
# ##################################################

# Create estop signal chain
# Drive software estop to hardware
net estop-out iocontrol.0.user-enable-out => bb_gpio.p8.out-19
setp bb_gpio.p8.out-19.invert 1

# Monitor estop input from hardware
net estop-loop bb_gpio.p9.in-41 => iocontrol.0.emc-enable-in
setp bb_gpio.p9.in-41.invert 1

# create signals for tool loading loopback
net tool-prep-loop iocontrol.0.tool-prepare => iocontrol.0.tool-prepared
net tool-change-loop iocontrol.0.tool-change => iocontrol.0.tool-changed

# Axis enable signal (active low)
#net emcmot.00.enable => bb_gpio.p8.out-07
#setp bb_gpio.p8.out-07.invert 1

# Machine power
# Use halui.machine.is-on instead?
net emcmot.00.enable => bb_gpio.p8.out-07

# Tie machine power signal to the Parport Cape LED
# Feel free to tie any other signal you like to the LED
net emcmot.00.enable => bb_gpio.p8.out-26

# ################
# Limit Switches
# ################
newsig limit-x-min bit
newsig limit-x-max bit
newsig limit-y-min bit
newsig limit-y-max bit
newsig limit-z-min bit
newsig limit-z-max bit

net limit-x-min <= i2c_gpio.A.in-01
net limit-x-max <= i2c_gpio.A.in-00
net limit-y-min <= i2c_gpio.A.in-03
net limit-y-max <= i2c_gpio.A.in-02
net limit-z-min <= i2c_gpio.A.in-05
net limit-z-max <= i2c_gpio.A.in-04

# Adjust as needed for your switch polarity
setp i2c_gpio.A.in-00.invert 1
setp i2c_gpio.A.in-01.invert 1
setp i2c_gpio.A.in-02.invert 1
setp i2c_gpio.A.in-03.invert 1
setp i2c_gpio.A.in-04.invert 1
setp i2c_gpio.A.in-05.invert 1

# Enable pullup for mechanical endstops
setp i2c_gpio.A.in-00.pullup 1
setp i2c_gpio.A.in-01.pullup 1
setp i2c_gpio.A.in-02.pullup 1
setp i2c_gpio.A.in-03.pullup 1
setp i2c_gpio.A.in-04.pullup 1
setp i2c_gpio.A.in-05.pullup 1

# Uncomment if you actually have limit switches setup
# You probably want to setup homing in the INI file, as well
net limit-x-min => axis.0.home-sw-in
#net limit-x-min => axis.0.neg-lim-sw-in
#net limit-x-max => axis.0.pos-lim-sw-in
net limit-y-min => axis.1.home-sw-in
#net limit-y-min => axis.1.neg-lim-sw-in
#net limit-y-max => axis.1.pos-lim-sw-in
#net limit-z-min => gantry.0.joint.00.home
#net gantry.0.limit => axis.2.home-sw-in
net limit-z-min => axis.2.home-sw-in
#net limit-z-min => axis.2.neg-lim-sw-in
#net limit-z-max => axis.2.pos-lim-sw-in

# ##################################################
# PWM and Temperature Signals
# ##################################################

# Define signals to use elsewhere (ie: M1xx codes)
# If you change any names here, lots of things will break!
newsig e0.temp.set   float
newsig e0.temp.meas  float
newsig bed.temp.set  float
newsig bed.temp.meas float


# Bed Heater FET 1
setp i2c_pwm.out-00.enable 1
setp i2c_pwm.out-00.value  0.0

# E0 Heater FET 2
setp i2c_pwm.out-01.enable 1
setp i2c_pwm.out-01.value  0.0

# Fan 1 FET 3
setp i2c_pwm.out-02.enable 1
setp i2c_pwm.out-02.value  0.0

# FET 4 - Fan / LED
setp i2c_pwm.out-03.enable 1
setp i2c_pwm.out-03.value  0.0

# FET 5 - Fan / LED
setp i2c_pwm.out-04.enable 1
setp i2c_pwm.out-04.value  0.0

# FET 6 - Fan / LED
setp i2c_pwm.out-05.enable 1
setp i2c_pwm.out-05.value  0.0

# FET 7 - Fan / LED
setp i2c_pwm.out-06.enable 1
setp i2c_pwm.out-06.value  0.0

# FET 8 - Fan / LED
setp i2c_pwm.out-07.enable 1
setp i2c_pwm.out-07.value  0.0


# PID for Extruder 0 temperature control
net e0.temp.meas    <= i2c_temp.ch-00.value
net e0.temp.meas    => pid.0.feedback

sets e0.temp.set  0
net e0.temp.set     => pid.0.command

net e0.heater  <= pid.0.output
net e0.heater  => limit1.0.in
net e0.heaterl <= limit1.0.out
net e0.heaterl => i2c_pwm.out-01.value

# Limit heater PWM to positive values
# PWM mimics hm2 implementation, which generates output for negative values
setp limit1.0.min 0
setp limit1.0.max 1


# PID for Bed temperature control
net bed.temp.meas    <= i2c_temp.ch-02.value
net bed.temp.meas    => pid.1.feedback

sets bed.temp.set  0
net bed.temp.set     => pid.1.command

net bed.heater  <= pid.1.output
net bed.heater  => limit1.1.in
net bed.heaterl <= limit1.1.out
net bed.heaterl => i2c_pwm.out-00.value

# Limit heater PWM to positive values
# PWM mimics hm2 implementation, which generates output for negative values
setp limit1.1.min 0
setp limit1.1.max 1


# PID Parameters for adjusting temperature control
# Extruder
#setp pid.0.FF0      0  
#setp pid.0.FF1      0  
#setp pid.0.FF2      0  
setp pid.0.Pgain     0.10
setp pid.0.Igain     0.00001
setp pid.0.Dgain     1.5
setp pid.0.maxerrorI 1.0
setp pid.0.bias      0.15 
setp pid.0.maxoutput 1.0 
setp pid.0.enable    1

#net pidctrl.Pgain => pid.0.Pgain
#net pidctrl.Igain => pid.0.Igain
#net pidctrl.Dgain => pid.0.Dgain
#net pidctrl.maxerrorI => pid.0.maxerrorI
#net pidctrl.bias => pid.0.bias
#net pidctrl.enable => pid.0.enable
#net pidctrl.command => pid.0.command
#net pidctrl.feedback <= pid.0.feedback

# Bed
#setp pid.1.FF0      0  
#setp pid.1.FF1      0  
#setp pid.1.FF2      0  
setp pid.1.Pgain  1
setp pid.1.Igain  0.0
setp pid.1.Dgain  0.0
setp pid.1.maxerrorI 1.0
setp pid.1.bias    0.5  
setp pid.1.enable   1

# ##################################################
# RGB LED
# ##################################################
newsig rgb_led.r   float
newsig rgb_led.g   float
newsig rgb_led.b   float
newsig rgb_led.r_in u32
newsig rgb_led.g_in u32
newsig rgb_led.b_in u32

net rgb_led.r => i2c_pwm.out-04.value
net rgb_led.g => i2c_pwm.out-05.value
net rgb_led.b => i2c_pwm.out-03.value

net rgb_led.r <= led-dim.0.output
net rgb_led.g <= led-dim.1.output
net rgb_led.b <= led-dim.2.output

#sets rgb_led.r 1.0
#sets rgb_led.g 1.0
#sets rgb_led.b 1.0
net rgb_led.r_in <= ledctrl.color.r
net rgb_led.r_in => led-dim.0.input
net rgb_led.g_in <= ledctrl.color.g
net rgb_led.g_in => led-dim.1.input
net rgb_led.b_in <= ledctrl.color.b
net rgb_led.b_in => led-dim.2.input

setp led-dim.0.factor 5.0
setp led-dim.0.steps  256
setp led-dim.0.max-pwm 4095
setp led-dim.1.factor 5.0
setp led-dim.1.steps  256
setp led-dim.1.max-pwm 4095
setp led-dim.2.factor 5.0
setp led-dim.2.steps  256
setp led-dim.2.max-pwm 4095

# ##################################################
# Fans
# ##################################################
newsig e0.fan.set   float
newsig e0.fan.pwm   float

# E0 Fan
net e0.fan.set => scale.0.in
net e0.fan.pwm <= scale.0.out
net e0.fan.pwm => i2c_pwm.out-02.value

setp scale.0.gain 0.00392156862745
sets  e0.fan.set 0.0

net e0.fan.set <= axis.4.motor-pos-cmd
net e0.fan.set => axis.4.motor-pos-fb

# FET 7 - Hotend Fan
setp i2c_pwm.out-06.value  1.0

# FET 8 - Housing Fan
setp i2c_pwm.out-07.value  1.0